Hello everyone. This video is for the doubts I had received for my previous video. So there were some commands and some steps on which I had assumed that audience may be aware of that and and from the flow of creating a container the explanation got skipped. So I have included all those things in this video. So let's start. So while creating our container we had one step like sorry

like while creating our container we had one step at which we had to do mounting like we have to mount prop we have to mount sis FS and tmpfs also. So what exactly is happening here? So let's understand this particular command mount type proc is executed when we create our container. So this mount type proc is mounted on / proc and it uses a particular directory for that. So here this part directory can be anything and we have mounted this procktype file system to this particular mount. So what exactly is this proc type file system? It is a virtual file system. So a virtual file system is a file system which does not have any files of its own but basically it acts as an interface between your user space and kernel. So whenever you interact with this proc mount point kernel will execute some processes and by those processes it will populate the contents of this proc folder like while mounting you are creating a virtual file system and that expose live kernel data structures and system information. So by virtual file system live kernel data structures are basically presented to the to the user space and also the system information. So by that this / proc or slash system acts as an interface to the kernel data that are dynamically generated when you access them. Let's further understand it. Like when you create proc file system, you can have content content like this one two. These are the process ids, current process simling, CPU info, memory info, uptime and whatn not. These are not the real files. Like if you check over here

basically we have not yet mounted. Let's mount mount type proc and let's give a gibberish name to it and keep the mount point at proc. See it will still work. it this particular P ids. If we check list / proc we can see we have these particular process ids 1 13 7 8 9 these process ids are dynamically created by the kernel by reading all the CPU stats and other things. So

continuing here like okay I have said these are not the real files we can understand it by taking example of ls like taking example of a proc process called uptime. So let's take this example. If we do cat process uptime. So this particular uptime is dynamically generated by kernel. Like if I execute it again and again. See the values are changing because these are not hardwritten. And if you do list proc uptime

see it has size zero. So how can these many contents let's even let's print the size of all the contents.

You can see most of them has zero size but I have just shown you the uptime has the values. So how come it has zero size? Because this proc here is a virtual file system is now it has become like when we have executed that mount command. This particular mount has become interface point for the kernel. So that kernel can communicate with our process and populate this much information to us. Likewise if we do mount system file system write any gibbus here / system. So that's how we are able to get the devices information and same goes for type temporary file system where we are creating a file system mount. So by that our file system will be in the separate mount. So again going back to our theory part. So whenever I have done list proc values are generated in real time by the kernel and it creates directory entries for each process that I have just shown you. Apart from that similarly slashes/ temporary mounts are done and slashes mount watch for devices and temporary fs mount watch for file system and apart from that there was also hyphen iPhone fox statement in our uh unshare command that we have executed to create our container. So why fox statement was executed? FK statement was executed because if we do unshare process ID without using fork like here the cell is itself is not in the new process ID name space like the new process ID name space do get generated but the cell process will remain in the parent name space. So for cell process to be available in a separate name space we have done hyphen fork after our all unshare commands. So uh fork is done. Next now study IPC name space. So IPC is nothing but inter interprocess communication. Suppose there were two process P1 P2 they are executing. So any communication between these two process is done by IPC. So IPC has two types system five IPC which are which has three ways shared memory message Q and SIMA force and postix IPC shared memory files in dev/shared memory. uh like message Q and Sema force are not we we are going to discuss today but uh like message Q is just like your simple Q in which you can share uh messages between different processes. Sema force is a concept by which you can allow different processes to access some data of critical section and when simma 4 value become less than zero you can prevent those other processes to access that critical section and when simma 4 value get incremented the other process can also access the critical section. So here we will study the shared memory type IPC. So what we will do we will create a 64 MB shared memory in our uh host system and like here this 64 MB memory is created. P1 P2 process both can use this shared memory and by using this shared memory they can have a communication between them. So that is IPC. So we will create IPC in our system. Let's go and create like here. If we do IPC MK IPC make- m 64 M shared memory ID is one. IPC - M that list the shared memory ID is one. And because we have started this particular container using hyphen ipc. So here we expect that same shared memory should not be available. And likewise that shared memory is not available here. Although in host system that shared memory is available. Like here set memory id is one because it has started with zero when like before recording video I had executed it first. So in when in your system it will start with zero. So now let's go on and remove this particular shared memory space.

So now in our system also shared memory space is deleted.

So by that we were able to understand three concepts. First one were was mounts, second was fork and third was IPC. And if I like elaborate mount again to you. So let's do it again. Whenever I have when I executed this particular command, let's say mount type proc then taken some arbitrary directory to a mount point proc. What exactly has happened is this slash proc become a gateway between my user space and kernel space. Whenever I interact with this prop mount point, kernel executes some processes, gets data and updates that data in the proc folders. So that's how this particular mount point was able to show process ID starting from one because in our host system process ID may have started from 2.8 73 but here process ID starting it from one because this / block mount point taken into account the name space of the container not the host. Okay. So I believe this mounting thing is clear now. So thank you.
