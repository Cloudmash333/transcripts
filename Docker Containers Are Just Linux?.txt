Hello everyone. I'm very excited for today's video because no one on YouTube or any other platform has explained internals of Docker containers in this much clarity. Please watch the full video and I promise you that this will increase your knowledge about containers to a different level. So let's get started. So before learning this, let's do the hello world for containers docker run interactive Ubuntu. So this will basically spin up our Ubuntu container like I have downloaded the Ubuntu image here. So yeah now we are in the containers. So like now we know we can move around and in my Mac there is Linux running currently now. So what can we exactly do here? We can run any NodeJS application, Python application and what not. But what exactly has happened when I have executed this docker run interactive Ubuntu command? Like if we see here that our Ubuntu image in images is only of 117 MB size and our container has whole Linux because Ubuntu ISO we know it is around 4 to uh 3GB. Then how come this Ubuntu is running on is running on my Mac by utilizing only 117 MB. So let's start. So these are the concept to learn about containers first principles. Like here we have different apps. Okay. These apps are basically images. These are running images. So these images are executing on a single machine. So this particular single machine in our case can be my MacBook. Like here we saw that in my MacBook one application of Ubuntu is running like this particular thing is Ubuntu or it could have been a NodeJS or any other application running within a container. So when I executed docker run Ubuntu what exactly has happened? So it must point out two questions within our mind. First one is what? Let's full screen it. What exactly is inside an image? Second question will be what or we can say how that is being executed within our system. or we can say any OS. So in this video we will answer these two questions internally or like Elon musk like to say it using first principles. So let's start here. This particular system is one machine. It can be a server or it can be your desktop. So here we have multiple containers running app 1, app 2, app 3 and for whole containers they have their different binaries libraries separately for them. Like here if we see in our terminal you can see this particular binary folder. If I go inside this binary folder, I can find various binaries. Like if I do ls grep cp, we have copy binary for this particular container. This particular copy binary is different from my Mac CP binary. So it has an operating system of its own. Well, it looks like that, but it is not a full operating system. It is just a container. Let's continue. So what exactly happens here is we have multiple containers running. All of these containers are handled by a layer called container daemon. This container demon follow open container interface standards and it actually manages all the containers and its images. And below the container daemon we have host operating system like Linux, Mac or Windows. Like in my case I have Mac. My host operating system is Mac and server is my personal Mac PC and container daemon is running within my PC and handling all these containers. So internally how container daemon handle all these containers. It has one library called runc. So let me show you runc here.

So if you go to this GitHub open containers initiative GitHub you have one repository called runc. This runc is implemented in Go language and what it actually does is let me show you here

this runc

executes our docker container in like here you can see runc is executing our docker container. Okay, let's go part by part otherwise I may confuse you. So, okay, we have set up our premises. All we know until now is we have container daemon. Container demon is running one or more images. And when my image gets executed, it's a container. Okay, let's move forward. And up till now just keep three things in your mind. These two questions what exactly is inside an image how that is being executed in our operating system. And third thing you must keep in your mind is container daemon. So those images are executed by container demon like we have deduced up till now. And what exactly inside in these images which has container daemon actually executed. So here it is like I have shown you earlier in binary folder I have shown you the CP right the CP binary like here. Let's see that again. This particular CP binary is inside our binary folders. Apart from that in this Ubuntu we also have the library folder. Library we all know we have the code which is used to run various other applications within alongside your binaries. Right? So in our image what exactly docker does is suppose you have this particular system it's your host operating system is there and then container demon is here. So it what container demon will do it will pull image from your docker registry. It can be ECR or it can be your simple docker registry and then it executes containers by using that image like sorry I have said docker registry it will pull image from docker registry and then it executes that image. So what exact code do we need inside an image so that we can have a system like this total system like this running in our host operating system. In fact I can even run hundreds and thousands of these kind of container within my single system. So just think what all files do we need. So we will actually be needing only the root file system some key directories let's say binaries system binaries library 64-bit libraries user directory etc directory temp proc system root home etc. Apart from that we will have image manifest and configuration. So more or less this particular image will have a file system for Linux like whatever that we can see here these all the things only these things are in the image and their size is dot size is not that much. Okay. So now we understand we have these particular folders within an image. So what are the exact things the image does not have actually. So let's move forward. So these are the exact things that image does not have. First and foremost image does not have the Linux kernel. Yes, kernel the core part of the operating system which talks to your hardware which takes system calls from your applications and executes all the hardware resources maybe CPU main memory and what not. Your image does not have Linux kernel. So okay now things are like clearing up a little bit. My this particular Ubuntu container which is running like this one I actually only have these many files or one or two configuration files listed here like these configuration files. It does not have the whole Linux kernel Mr. Torvalds has implemented. Okay, let's see more. It does not have Linux kernel and it does not have device drivers like the mouse I'm using the keyboard and the Ethernet my system is connected to. It is not using the device drivers within my container. Although if I run any network command within my container, it will execute. How it will execute? It will use the Linux kernel of the host.

See the host Linux kernel will be used to execute the container code. So okay, let's quickly round this up. We don't have Linux kernel. We don't have device driver and obviously if we don't have Linux kernel and device driver we will not be having hardware specific code. We will not be having the init system. Okay, let's let me tell you something more here. This systemd is an init system in our Ubuntu. So like process get started due to which and it also handle the services in container. The process ID starts with one only. So it doesn't need a system dc container. Oh sorry system d service. I'm saying containers lots of time. Okay. So let's wind this part. Uh we don't have l kernel device drivers hardware specific code system services and also desktop environment office games media player and many more things. And all of these things are available in your Ubuntu ISO. Like when you have dual booted your systems using Ubuntu ISO and Windows that Ubuntu ISO also contains these many separate things. So by container only in our container we only have the needed files. And let me tell you one more thing like suppose I go here like uh uh you know like whether I want if I want to create one file let's make directory test change directory test see this container or this behaving like Linux only create a file a txt oh we have file And let's put something inside it. Echo cloudm.xt.

Oh, I need dot

cat a.txt. Wa it is behaving like a simple Ubuntu container. But can I do other things that I do in my Ubuntu system? Suppose doing nano a.txt. Whoa, it doesn't have nano editor. Okay, if it doesn't have nano editor, let's try vi via a.txt. Okay, it doesn't have vi also. H. So basically even though it looks like an Ubuntu system running on your Mac it doesn't have some basic things like I told you here it doesn't have uh in it systemd service even to start with and like forget about the other things. So by that it is clear that containers are made for some different purpose. It doesn't have the kernel, the device drivers, hardware specific code or system services or desktop environment and other things. But it does have some initials files to start with. Okay. Now you will say how the hell this file help me like I don't want CP or ls command to execute in my server using container then how will I use it let's move forward so here you can see let me check if it is visible properly okay so here it is our host system and our container like I have shown you to container running. So our host system have it own binaries, libraries and user directory and container also have its own binaries, libraries and user directory. Both of the host system and container will make system calls to my kernel. H okay now things are making sense. Basically container is only up to here. Before kernel there is container after kernel and down below there is no container specific code. Our containers is a separate space running with its separate binary files and calling Linux kernel for a task without interfering with the host system. like host system cannot call any binaries of container as well as container cannot call any binaries of host system. Okay. What advantage this give us? Like suppose you we developers we face this particular dilemma that it's a very famous dilemma like my code works in my

local

but it doesn't work in my PD server. So why it happens? Like most of the time developer face this thing like their code works perfectly in local because in their local host system all the necessary binaries and setup for that software is there. But as long as that sometimes when their code goes to production their code fails because some binary some setup some installation of some particular code is not up to the mark needed for their code to run. So basically what happens with container I did what I did here. Suppose I want to make an simple NodeJS application. Let's take different colour otherwise get mixed with this.

So suppose you want to make a NodeJS application. What exact things you need? you need NodeJS for sure. Apart from that if I give you some binaries, some libraries and some user and all the other directory structure like this

this over here

some directory structure like this only catered to your needs of running a NodeJS application. only. So what will happen all the setup all the files like some auxiliary files and some configuration that you will execute with your NodeJS. Uh although NodeJS is also a very good topic. Uh I can explain event loop with microtask q task q and how the system calls and call backs are getting getting executed. So please comment down below if you need that video. So all the NodeJS specific file in your single container and also your JavaScript code for which your API server will be running. Once I package it inside a container, what it container actually has? This container will only have my application. And when this container will be deployed to production, it will not interfere with production host system binaries and will only deal with production kernel and make system calls to the kernel and then executes its code and it will never face the dilemma of developer in which its code works in local but doesn't work on the production. So here if we down below we can see we also have another extraction like okay we know we can make system calls via container to our Linux kernel and then Linux kernel will call our hardware CPU and memory. So apart from that there are two specific concepts how by which containers are able to execute and those two are liner specific content uh concepts like till now we have done this much like what is exactly inside the image like this part is done we know what exactly inside the image it has some system binaries specific to your code and by that your code is executing. Like here also you can see app 1 has its own binaries and libraries. App 2 has its own binaries and libraries. App has its own binaries and libraries. And all of this is handled by container demon. And the as if we talk about size the 12 image size compressed is 72 MB. after pulling and decompressing it, it is only 100 to 200 MB. Apart from that, Ubuntu ISO size is 4.7 GB and 1.4 GB. Why? Because we know it has these many things with it. Linus scanner device driver desktop environment systemd and what not. So as of now our dispeller question is answered. Now remain the second question. how this is being executed in our operating system. Like if I give you the binaries, these system binaries in a zipped format in Windows or Mac or Linux, can you actually execute it in a separate container? No, they are not directly executable in a separate container. For that you need basically two things. Let me tell you here only.

So as we know now we have one image and suppose this image is uncompressed. It has our binaries and our code. So what exact thing your system needs to do so that it can run this particular image. source your system will create will take the help of two Linux concept. First one is name spaces.

Second one is croups.

Okay, let me write it correctly. You might be hearing for first time and you don't want to see bad spelling and although you are seeing my bad handwriting. Sorry for that. So you will need these two concepts. So what exactly a namespace does? Namespace will create seven different name spaces for your container to run. Suppose it we have process ID name space, we have network nameace, we have mount name space, we have user name space and seven more. And let me explain you with example of process ID. Like whenever your Linux system gets started and you run any application on your Linux system, there is one process ID associated with that application. Like suppose you're running some Python code that Python code has processor ID maybe like 4 63 something like that. So process ID name space what it does is within your Linux system it will create an another space in which process ID will start by one only. Okay. Like this system is your Linux and this is your we can say private namespace. In fact, let me draw this here.

Yeah. Okay. So, let's understand it here only by starting. In starting your container demon will pull image from docker repository. It can be a docker repository or amazon. So here what happens your image gets transported to container demon like now image is here. So container demon will create OCI runtime spec and create container root file system and then container demon will call run C and run C will create this particular name spaces for your container to run. Let me explain you. Suppose this is your Linux system. Okay, you have an image here with all the code and binaries. Here it has created the process ID name space. Let's call it P ID.

So what this particular process id name space has extra it has its own process ID starting by one as parent process and all the process ID P1 P2 all the processes running here in this particular space will cannot interfere with the Linux processes running here. Okay. So this particular thing is called process ID name space. So run has created a process ID name space. After that it will create a network name space. Let's take different colour. This will be our network name space. So what network name space give us is it will give us its different network tables and network connections like there's a concept of ETH in Linux. So all the network connections will be different for this particular space. Let's move forward. Then we will have mount name space. So in mount name space we will have our different file system mounted in this particular name space. So what mount name space have done here is like uh whenever you are in this particular whenever you do like how mount work is whenever you do see change directly to a particular mount then you are basically uh be uh shown to that particular mount directory contents. So okay uh let me explain it in more simple words. uh I have to give you example here like please bear with me if this name space things are not clear I will have a separate window video video lines up for that here I will only telling the abstract details how a Linux name spaces are getting created like suppose you have connected a pen drive to your Linux system so this will be your pen drive so your pen drive is at /dev/ a particular location. If you mount suppose you have one directory named ABC. If you mount your pen drive this to this directory ABC and then you do C directory to ABC then going inside the C ABC directory you will see contents which are inside your

pen drive basically. So if ABC is mounted with dev A you will get contents of the pen drive in the directory ABC because ABC is mounted. So just like this our docker container is also making a different name space for the mount. Okay. So just understand it like that. Now we have another namespace called UTS namespace. UTS name space is used for like domain name and host name. Host name we know we it's the name of our system. Domain name we know it's the name of our domain like domain of our system like fully like you must have heard about F fully qualified DNS name FQDN. This is our host name dot domain name. So this naming part of the container is done by UTS. And another name space is our IPC which is interprocess communication namespace and then at last we have our username space.

Okay. So basically now if you have not understood all this just forget it and just remember the thing I'm going to tell you. What you have to remember here name spaces are created one logical space inside Linux. this all of these name spaces have created a logical space inside the nuance where our extracted image can execute. Okay, once I have like all these things this process ID, network mount name space, you can run a simple Linux command in your Linux system and create all of this. And if you create all of these seven in your Linux command in your Linux system you have you will end up with a logical space which is entirely different from your host system and this particular space is nothing but the space in which our image is running. So our image extracted image can run here. how it has in its different process ids. It has its different network settings. It has a different mount. It has a different domain, different interprocess communication, different users. And then one last thing it has like we know like this logical space will also take our CPU plus memory resources. So we specify the CPU and memory resources using Cgroup. Croup is also a Linux concept. So by croup we can specify how much CPU like suppose we want to say our container will use one or two cores from your 8 core CPU and it will take around 6 GB memory. So all of this setting you will specify in the croup. So let me write it here. Croup setting one CPU 2 GB of main memory. So what exactly has been done here? We have let's say

Croup here this is three. We have our logical space second and first and foremost our image like this will be our first part. All of these first image then logical group and then croup will make our container. Like if we do first plus 2 + 3 it will make our container and all of this is not magic. This name spaces is a Linux concept. This croup is a Linux concept and image is just some Linux separate Linux binaries separate CP separate GCC binaries and your own code running. All of these three combined and execute into a container. We had started from here. Right? We have one container demon. Container demon is handling our containers. And we have our host operating system. We have seen the liner file system. Linux image like our particular Linux image or any container image have only has binaries and some manifestation code and it doesn't have Linux kernel or device drivers and our container and host will share same Linux kernel and hardware. Okay. So now let's see what exactly happens if I just execute this particular command. docker run interactive Ubuntu. [Music] So what it will do it will first go to the container demon will take charge from here and it goes to the docker repository like docker hub or amazon. It downloads the Ubuntu image, creates a OCI open container initiative runtime spec and create the container root file system and then it transfer the control to run C. What run C does? Run C have does two very critical tasks. It will create the name spaces and allot the croup limits like name spaces I have already told you it's a logical space within our Linux system and croups is used to specify CPU and memory limit that our logical space is allowed to take and after se creating logical space and the C grouping run C will execute our image like for that there are some different functions it will change the root file system of for the container it jails the process to the container file system using chroot like this chr root ch root term you will see when you like read more about containers it actually jails the process container file system so after that in It execute the specify command in the entry point like you remember in your docker file after writing from you write run this. So this particular run is your entry point. This one is also done by the run C and then it handles signal between host and the container. So host is our main system and container is the one running in our host. So container will now interact with our Linux kernel and execute as per specification given in its image. So basically now we have come to know about answer for our these two questions that what is inside an image and how that is being executed in operating system. It is getting executed in our operating system using a library called run C. Run Creates name spaces. Run C allot Croup settings and run C then executes our image inside uh that particular logical space which we call container. And here I can show you actually the run see here.

So this particular uh run repository like runc is not something library internal code it is actually a command line tool to run your containers. So basically what you can do here is like suppose you have runc installed in your system like run is implemented in go language. So you can easily execute run C command line interface like so here run command line interface will create a container for you and here container will be handled by run and all its particular states are also handled by run. Like here if we see the code of RNC here it is if we go and check here what I have seen yeah library container inside library container if we go into factory Linux.go in factory Linux.go go we have code to create a container. So that's how run creates container and in run main command you will see it's it's just a command line tool like if I go in main.go Go. You can see like here command interface bool flag command line interface string bool like these particular command line interface flags are there debug log root and what not. So here run is just a command line tool which is used by the container demon. So you must have been thinking like what is the task of container demon. Then container demons basically handles the pulling and pushing of repository from the docker registry and creating OCR runtime spec and then creating container root file system and after that passing on control to run C. So container demon will fetch our image and it transferred imi the image to the runc like in whole tutorial we have called this an image. We could have called this only uh file.zip and it transferred a file.zip to run c run creates its so-called magic which has two steps creating Linux name spaces and creating croups. So as now we get uh like acquainted with the concept of the containers like how container demon is running different containers using run C and within different host like Linux, Mac and Windows and a different server Intel or Graviton. So this has provided us very much advantages. It has save saved us from developer dilemma that my code works in my local and not in my server. It has saved us from different implementations because see the core logic here was this particular thing like we see here. If I share my Linux kernel and hardware and separate host system with container, I can do anything in container because basically at the end of the day my Linux kernel will deal with system call like it will open file descriptor and close file descriptor wait for e sockets and whatn not. But our like abstracted code is which is being executed in JavaS uh NodeJS or Python is needed only few system binaries. So that was the major intuition here because system binaries are very low in size and if we jails our process in this particular name space and uh only restrict our process to use a particular CPU and memory limit using croup and jailing it with n Linux name spaces. we can actually run multiple containers in a single system using same Linux kernel. So like uh I believe I was able to like explain you all about the Linux or about containers and docker containers and images. If you need any more video like I will be making a second series of this video explaining the Linux name spaces in detail because here I have just explained you it will give you separate P separate network and separate mount space. In that particular video I will be explaining you how you can create these particular Linux name spaces within your Ubuntu system. Okay. and we will see if we can specify cgroups and make a our custom made container. So that's all for today. Uh it was like very it was very hard and also exciting to learn all this and present you here in this format. So if you have and gained any knowledge or found it interesting so please share it with your friends and like and subscribe my video like it's just a single click from you but it will push me more to create more videos like this and we can learn together. So thank